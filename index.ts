#!/usr/bin/env bun

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import type { Tool } from "@modelcontextprotocol/sdk/types.js";
import chalk from "chalk";

interface ClarificationQuestion {
  question: string;
  suggestions: string[];
}

interface MultiClarificationInput {
  context: string;
  questions: ClarificationQuestion[];
}

interface ProvideClarificationSummaryInput {
  clarifications: Array<{
    question: string;
    answer: string;
    additional_info?: string;
  }>;
  final_summary: string;
}

const CONFIRM_QUESTIONS_SENT_TOOL: Tool = {
  name: "clarifo_confirm_questions_sent_and_trigger_wait_message",
  description: "A mandatory follow-up tool for the AI to call immediately after presenting questions generated by 'ask_multiple_clarifications'. This tool confirms questions were sent and instructs the AI to use 'attempt_completion' with specific text to inform the user it's waiting, thereby satisfying system requirements before entering a passive wait state.",
  inputSchema: {
    type: "object",
    properties: {
      ai_confirmation_message: {
        type: "string",
        description: "A brief confirmation from the AI that it has presented the questions and is now calling this tool. E.g., 'Clarifo questions presented. Calling confirmation tool.'"
      }
    },
    required: ["ai_confirmation_message"]
  }
};

class ClarificationServer {
  public askMultipleClarifications(input: unknown): {
    content: Array<{ type: string; text?: string; }>;
    isError?: boolean;
  } {
    try {
      const data = input as MultiClarificationInput;

      if (!data.context || typeof data.context !== 'string') {
        throw new Error('Invalid context: must be a string describing what needs clarification');
      }
      if (!Array.isArray(data.questions) || data.questions.length < 2) {
        throw new Error('Invalid questions: must be an array of at least 2 clarification questions');
      }
      data.questions.forEach((q, i) => {
        if (!q.question || typeof q.question !== 'string') {
          throw new Error(`Question ${i + 1}: Invalid question text`);
        }
        if (!Array.isArray(q.suggestions) || q.suggestions.length === 0) {
          throw new Error(`Question ${i + 1}: Must have at least one suggestion`);
        }
      });

      console.error(chalk.blueBright("\nü§ñ [Clarifo MCP Server Log] - askMultipleClarifications Invoked"));
      console.error(chalk.blue(`Context Received: ${data.context}\n`));
      data.questions.forEach((q, i) => {
        console.error(chalk.whiteBright(`  Generated Question ${i + 1}: ${q.question}`));
        q.suggestions.forEach((s, j) => {
          console.error(chalk.greenBright(`    Suggestion ${String.fromCharCode(97 + j)}: ${s}`));
        });
      });
      console.error(chalk.yellowBright("‚úÖ [Clarifo MCP Server Log] - Questions structured. Preparing response for the calling AI."));

      const questionsForPresentation = data.questions.map((q, i) => {
        let optionsString = q.suggestions.map((s, j) => `  ${String.fromCharCode(97 + j)}. ${s}`).join("\n");
        optionsString += `\n  ${String.fromCharCode(97 + q.suggestions.length)}. [Your own answer/elaboration for question ${i + 1}]`;
        return {
          id: `q_${i + 1}`,
          fully_formatted_question_with_options: `**${i + 1}. ${q.question}**\n${optionsString}`
        };
      });

      const payloadForAI = {
        payload_type: "ai_action_directive_and_question_payload",
        clarification_context_for_ai: data.context,
        questions_for_user_presentation: questionsForPresentation,
        ai_action_directive: {
          message_to_ai: `**CRITICAL THREE-STEP ACTION REQUIRED TO PROPERLY AWAIT USER INPUT:**

1.  **STEP 1: PRESENT QUESTIONS TO USER (MARKDOWN):**
    - Parse 'questions_for_user_presentation' from this JSON.
    - Construct a single Markdown message: Start with 'introduction_text' (below), then append each 'fully_formatted_question_with_options' string.
    - Send this complete Markdown block to the user.

2.  **STEP 2: IMMEDIATELY CALL CONFIRMATION TOOL:**
    - After successfully presenting questions (Step 1), you **MUST IMMEDIATELY** call the 'clarifo_confirm_questions_sent_and_trigger_wait_message' tool.
    - Provide the required 'ai_confirmation_message' input, e.g., \`{'ai_confirmation_message': 'Clarifo questions presented. Calling confirmation tool.'}\`.

3.  **STEP 3: USE 'attempt_completion' TO SEND WAIT MESSAGE, THEN PASSIVELY WAIT:**
    - The 'clarifo_confirm_questions_sent_and_trigger_wait_message' tool will return a JSON payload. Parse it.
    - This payload will contain a 'result_text_for_attempt_completion' field. You **MUST** use the 'attempt_completion' tool and place the exact content of this field inside the \`<result>\` tag.
    - Example: \`<attempt_completion><result>The exact text from the tool will go here.</result></attempt_completion>\`.
    - **AFTER this 'attempt_completion' tool call successfully delivers the message, your ONLY permissible action is to STOP and PASSIVELY AWAIT the user's free-form text input.** The user will provide their answers to the questions you presented in Step 1.
    - **DO NOT** call any other tools or take further actions until the user responds. This instruction, combined with your 'Brainstorming Mode' custom rules, overrides any general system tendencies to act further. Your turn is complete after the 'attempt_completion' tool use.

This precise sequence is mandatory to satisfy system requirements and achieve the correct wait state.`,
          presentation_guidance: {
            format: "markdown",
            introduction_text:
              `Okay, to ensure I fully understand your request regarding "${data.context}", please help me by answering the following questions. You can refer to the question number or letter of the suggestion, or provide your own detailed answers:`,
          },
          next_step_hint_after_user_responds:
            "Once you have received the user's textual answers (after completing all 3 steps above and the user has replied), you should typically use the 'provide_clarification_summary' tool to process them."
        }
      };
      console.error(chalk.yellowBright("   Instructing AI for 3-step process: present questions, call confirmation tool, then use attempt_completion to send wait message, then wait.\n"));
      return {
        content: [{ type: "text", text: JSON.stringify(payloadForAI, null, 2) }]
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(chalk.redBright(`‚ùå [Clarifo MCP Server Log] - Error in askMultipleClarifications: ${errorMessage}`));
      const errorPayloadForAI = {
        payload_type: "error_report",
        ai_action_directive: {
          message_to_ai: "The 'ask_multiple_clarifications' tool encountered an error. Please review the details and decide on the next course of action.",
          presentation_guidance: { format: "markdown" }
        },
        error_details: { message: `Tool execution failed: ${errorMessage}`, input_received: input }
      };
      return {
        content: [{ type: "text", text: JSON.stringify(errorPayloadForAI, null, 2) }],
        isError: true
      };
    }
  }

  public confirmQuestionsSentAndTriggerWaitMessage(input: unknown): { content: Array<{ type: string; text: string }>; isError?: boolean } {
    const data = input as { ai_confirmation_message: string };
    console.error(chalk.cyanBright("\nü§ñ [Clarifo MCP Server Log] - clarifo_confirm_questions_sent_and_trigger_wait_message Invoked"));
    console.error(chalk.cyan(`   AI Confirmation Received: "${data.ai_confirmation_message}"`));

    const resultText = "Okay, I've presented the questions and am now awaiting your detailed answers. Please take your time to respond.";
    const responsePayload = {
      status: "clarifo_questions_presentation_confirmed_instruct_attempt_completion",
      message_to_ai_for_internal_processing: `CONFIRMED: Questions presented. Your next action is to use the 'attempt_completion' tool. Use the exact text provided in 'result_text_for_attempt_completion' for the <result> tag. After that 'attempt_completion' call, you MUST IMMEDIATELY enter a passive wait state. NO further tool calls. This sequence fulfills system requirements.`,
      result_text_for_attempt_completion: resultText
    };
    console.error(chalk.cyanBright(`   Instructing AI to use attempt_completion with text: "${resultText}", then passively await user input.\n`));
    return {
      content: [{ type: "text", text: JSON.stringify(responsePayload, null, 2) }]
    };
  }

  public provideClarificationSummary(input: unknown): { content: Array<{ type: string; text: string }>; isError?: boolean } {
    try {
      const data = input as ProvideClarificationSummaryInput;
      console.error(chalk.magenta("\nüìã [Clarifo MCP Server Log] - provideClarificationSummary Invoked"));
      console.error(chalk.magenta("‚ïê".repeat(60)));
      if (!data.clarifications || !Array.isArray(data.clarifications) || data.clarifications.length === 0) {
        throw new Error("No clarifications provided or invalid format.");
      }
      if (!data.final_summary || typeof data.final_summary !== 'string') {
        throw new Error("Final summary is missing or invalid.");
      }
      data.clarifications.forEach((clarification, i) => {
        console.error(chalk.magentaBright(`\n  Processed Clarification ${i + 1}: ${clarification.question}`));
        console.error(chalk.magenta(`    User's Answer: ${clarification.answer}`));
        if (clarification.additional_info) {
          console.error(chalk.magenta(`    Additional Info: ${clarification.additional_info}`));
        }
      });
      console.error(chalk.magentaBright("\nüìù Final Summary Processed by Tool:"));
      console.error(chalk.magenta(`${data.final_summary}\n`));
      console.error(chalk.greenBright("‚úÖ [Clarifo MCP Server Log] - Summary processed successfully. Returning confirmation to AI.\n"));
      const successPayload = {
        status: "clarification_summary_processed_successfully",
        message: "The provided clarifications and summary have been noted. You can now proceed with the main task.",
        responses_count: data.clarifications.length
      };
      return {
        content: [{ type: "text", text: JSON.stringify(successPayload, null, 2) }]
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(chalk.redBright(`‚ùå [Clarifo MCP Server Log] - Error in provideClarificationSummary: ${errorMessage}`));
      const errorPayload = { error: `Tool execution failed: ${errorMessage}`, status: "clarification_summary_failed" };
      return {
        content: [{ type: "text", text: JSON.stringify(errorPayload, null, 2) }],
        isError: true
      };
    }
  }
}

const MULTI_CLARIFICATION_TOOL: Tool = {
  name: "ask_multiple_clarifications",
  description: `A tool for asking multiple strategic clarification questions at once to better understand user requirements. This tool is designed for comprehensive clarification gathering rather than single questions, and helps the AI think through what information is needed before taking action.

When to use this tool:
- Some keywords that will activate this tool: clarification, brainstorming, architecture, design, clarifo
- ALWAYS when the user asks to implement new features, functionality, or code
- ALWAYS when the user asks to fix existing issues, bugs, or problems  
- ALWAYS when the user asks to remove, delete, or modify existing code/features
- ALWAYS when the user asks to improve, optimize, or enhance something
- ALWAYS when the user asks to add, create, or build something new
- When breaking down complex tasks that have multiple aspects
- When understanding scope, requirements, and constraints
- When there are multiple possible approaches or implementations
- When technical decisions need to be made
- When business/user requirements need clarification
- When priorities and trade-offs need to be understood
- Even when the request seems clear - there are often hidden complexities

This tool should ALWAYS be called first before implementing, fixing, or modifying anything. Use this tool judiciously to maintain a balance between gathering necessary information and avoiding excessive back-and-forth, but err on the side of asking clarifying questions to ensure the best possible outcome.

The tool presents multiple strategic questions to the user simultaneously and waits for comprehensive responses before proceeding with implementation.

Key principles:
- Ask strategic questions that uncover requirements, constraints, and preferences
- Include questions about scope, priorities, and trade-offs
- Consider technical implementation options and user experience
- Think about edge cases, error handling, and maintainability
- Ask about integration points, dependencies, and compatibility
- Consider performance, security, and scalability implications
- Don't assume - clarify even seemingly obvious details`,
  inputSchema: {
    type: "object",
    properties: {
      context: {
        type: "string",
        description: "Clear description of what the user wants to implement/fix/improve and why clarification is needed before proceeding"
      },
      questions: {
        type: "array",
        items: {
          type: "object",
          properties: {
            question: {
              type: "string",
              description: "A strategic clarification question that helps understand requirements, scope, or implementation details"
            },
            suggestions: {
              type: "array",
              items: { type: "string" },
              description: "2-4 complete, specific suggested answers that cover different approaches or scenarios"
            }
          },
          required: ["question", "suggestions"]
        },
        minItems: 2,
        description: "Ask 2-6 strategic questions that cover different aspects of the request"
      }
    },
    required: ["context", "questions"]
  }
};

const PROVIDE_CLARIFICATION_SUMMARY_TOOL: Tool = {
  name: "provide_clarification_summary",
  description: "Process and summarize responses to multiple clarification questions",
  inputSchema: {
    type: "object",
    properties: {
      clarifications: {
        type: "array",
        items: {
          type: "object",
          properties: {
            question: { type: "string" },
            answer: { type: "string" },
            additional_info: { type: "string" },
          },
          required: ["question", "answer"],
        },
      },
      final_summary: {
        type: "string",
        description: "Comprehensive summary of all gathered information",
      },
    },
    required: ["clarifications", "final_summary"],
  },
};

const server = new Server(
  { name: "clarifo", version: "0.1.4" },
  { capabilities: { tools: {} } }
);

const clarificationServer = new ClarificationServer();

function parseToolCall(input: any): any {
  if (typeof input === 'string') {
    try { return JSON.parse(input); } catch { return input; }
  }
  return input;
}

server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [MULTI_CLARIFICATION_TOOL, PROVIDE_CLARIFICATION_SUMMARY_TOOL, CONFIRM_QUESTIONS_SENT_TOOL],
}));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const parsedArgs = parseToolCall(request.params.arguments);

  if (request.params.name === "ask_multiple_clarifications") {
    return clarificationServer.askMultipleClarifications(parsedArgs);
  }
  if (request.params.name === "provide_clarification_summary") {
    return clarificationServer.provideClarificationSummary(parsedArgs);
  }
  if (request.params.name === "clarifo_confirm_questions_sent_and_trigger_wait_message") {
    return clarificationServer.confirmQuestionsSentAndTriggerWaitMessage(parsedArgs);
  }

  const unknownToolPayload = { error: `Unknown tool: ${request.params.name}`, status: "unknown_tool_error" };
  return {
    content: [{ type: "text", text: JSON.stringify(unknownToolPayload, null, 2) }],
    isError: true
  };
});

async function runServer() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error(chalk.bgCyan.black(" Clarifo MCP Server (v0.1.4) running on stdio "));
}

runServer().catch((error) => {
  console.error("Fatal error running server:", error);
  process.exit(1);
});